// Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `
  type AggregateDevCategory {
    count: Int!
  }

  type AggregateDevice {
    count: Int!
  }

  type AggregateLoan {
    count: Int!
  }

  type AggregateUser {
    count: Int!
  }

  type BatchPayload {
    count: Long!
  }

  scalar DateTime

  type DevCategory {
    id: ID!
    deviceType: String
    desription: String
    createdAt: DateTime!
    updatedAt: DateTime!
  }

  type DevCategoryConnection {
    pageInfo: PageInfo!
    edges: [DevCategoryEdge]!
    aggregate: AggregateDevCategory!
  }

  input DevCategoryCreateInput {
    id: ID
    deviceType: String
    desription: String
  }

  input DevCategoryCreateOneInput {
    create: DevCategoryCreateInput
    connect: DevCategoryWhereUniqueInput
  }

  type DevCategoryEdge {
    node: DevCategory!
    cursor: String!
  }

  enum DevCategoryOrderByInput {
    id_ASC
    id_DESC
    deviceType_ASC
    deviceType_DESC
    desription_ASC
    desription_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
  }

  type DevCategoryPreviousValues {
    id: ID!
    deviceType: String
    desription: String
    createdAt: DateTime!
    updatedAt: DateTime!
  }

  type DevCategorySubscriptionPayload {
    mutation: MutationType!
    node: DevCategory
    updatedFields: [String!]
    previousValues: DevCategoryPreviousValues
  }

  input DevCategorySubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: DevCategoryWhereInput
    AND: [DevCategorySubscriptionWhereInput!]
    OR: [DevCategorySubscriptionWhereInput!]
    NOT: [DevCategorySubscriptionWhereInput!]
  }

  input DevCategoryUpdateDataInput {
    deviceType: String
    desription: String
  }

  input DevCategoryUpdateInput {
    deviceType: String
    desription: String
  }

  input DevCategoryUpdateManyMutationInput {
    deviceType: String
    desription: String
  }

  input DevCategoryUpdateOneRequiredInput {
    create: DevCategoryCreateInput
    update: DevCategoryUpdateDataInput
    upsert: DevCategoryUpsertNestedInput
    connect: DevCategoryWhereUniqueInput
  }

  input DevCategoryUpsertNestedInput {
    update: DevCategoryUpdateDataInput!
    create: DevCategoryCreateInput!
  }

  input DevCategoryWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    deviceType: String
    deviceType_not: String
    deviceType_in: [String!]
    deviceType_not_in: [String!]
    deviceType_lt: String
    deviceType_lte: String
    deviceType_gt: String
    deviceType_gte: String
    deviceType_contains: String
    deviceType_not_contains: String
    deviceType_starts_with: String
    deviceType_not_starts_with: String
    deviceType_ends_with: String
    deviceType_not_ends_with: String
    desription: String
    desription_not: String
    desription_in: [String!]
    desription_not_in: [String!]
    desription_lt: String
    desription_lte: String
    desription_gt: String
    desription_gte: String
    desription_contains: String
    desription_not_contains: String
    desription_starts_with: String
    desription_not_starts_with: String
    desription_ends_with: String
    desription_not_ends_with: String
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    AND: [DevCategoryWhereInput!]
    OR: [DevCategoryWhereInput!]
    NOT: [DevCategoryWhereInput!]
  }

  input DevCategoryWhereUniqueInput {
    id: ID
    deviceType: String
  }

  type Device {
    id: ID!
    idCode: String!
    manufacture: String
    model: String
    info: String
    loanStatus: Boolean!
    devCategoryId: DevCategory!
    createdAt: DateTime!
    updatedAt: DateTime!
  }

  type DeviceConnection {
    pageInfo: PageInfo!
    edges: [DeviceEdge]!
    aggregate: AggregateDevice!
  }

  input DeviceCreateInput {
    id: ID
    idCode: String!
    manufacture: String
    model: String
    info: String
    loanStatus: Boolean
    devCategoryId: DevCategoryCreateOneInput!
  }

  input DeviceCreateOneInput {
    create: DeviceCreateInput
    connect: DeviceWhereUniqueInput
  }

  type DeviceEdge {
    node: Device!
    cursor: String!
  }

  enum DeviceOrderByInput {
    id_ASC
    id_DESC
    idCode_ASC
    idCode_DESC
    manufacture_ASC
    manufacture_DESC
    model_ASC
    model_DESC
    info_ASC
    info_DESC
    loanStatus_ASC
    loanStatus_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
  }

  type DevicePreviousValues {
    id: ID!
    idCode: String!
    manufacture: String
    model: String
    info: String
    loanStatus: Boolean!
    createdAt: DateTime!
    updatedAt: DateTime!
  }

  type DeviceSubscriptionPayload {
    mutation: MutationType!
    node: Device
    updatedFields: [String!]
    previousValues: DevicePreviousValues
  }

  input DeviceSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: DeviceWhereInput
    AND: [DeviceSubscriptionWhereInput!]
    OR: [DeviceSubscriptionWhereInput!]
    NOT: [DeviceSubscriptionWhereInput!]
  }

  input DeviceUpdateDataInput {
    idCode: String
    manufacture: String
    model: String
    info: String
    loanStatus: Boolean
    devCategoryId: DevCategoryUpdateOneRequiredInput
  }

  input DeviceUpdateInput {
    idCode: String
    manufacture: String
    model: String
    info: String
    loanStatus: Boolean
    devCategoryId: DevCategoryUpdateOneRequiredInput
  }

  input DeviceUpdateManyMutationInput {
    idCode: String
    manufacture: String
    model: String
    info: String
    loanStatus: Boolean
  }

  input DeviceUpdateOneRequiredInput {
    create: DeviceCreateInput
    update: DeviceUpdateDataInput
    upsert: DeviceUpsertNestedInput
    connect: DeviceWhereUniqueInput
  }

  input DeviceUpsertNestedInput {
    update: DeviceUpdateDataInput!
    create: DeviceCreateInput!
  }

  input DeviceWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    idCode: String
    idCode_not: String
    idCode_in: [String!]
    idCode_not_in: [String!]
    idCode_lt: String
    idCode_lte: String
    idCode_gt: String
    idCode_gte: String
    idCode_contains: String
    idCode_not_contains: String
    idCode_starts_with: String
    idCode_not_starts_with: String
    idCode_ends_with: String
    idCode_not_ends_with: String
    manufacture: String
    manufacture_not: String
    manufacture_in: [String!]
    manufacture_not_in: [String!]
    manufacture_lt: String
    manufacture_lte: String
    manufacture_gt: String
    manufacture_gte: String
    manufacture_contains: String
    manufacture_not_contains: String
    manufacture_starts_with: String
    manufacture_not_starts_with: String
    manufacture_ends_with: String
    manufacture_not_ends_with: String
    model: String
    model_not: String
    model_in: [String!]
    model_not_in: [String!]
    model_lt: String
    model_lte: String
    model_gt: String
    model_gte: String
    model_contains: String
    model_not_contains: String
    model_starts_with: String
    model_not_starts_with: String
    model_ends_with: String
    model_not_ends_with: String
    info: String
    info_not: String
    info_in: [String!]
    info_not_in: [String!]
    info_lt: String
    info_lte: String
    info_gt: String
    info_gte: String
    info_contains: String
    info_not_contains: String
    info_starts_with: String
    info_not_starts_with: String
    info_ends_with: String
    info_not_ends_with: String
    loanStatus: Boolean
    loanStatus_not: Boolean
    devCategoryId: DevCategoryWhereInput
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    AND: [DeviceWhereInput!]
    OR: [DeviceWhereInput!]
    NOT: [DeviceWhereInput!]
  }

  input DeviceWhereUniqueInput {
    id: ID
    idCode: String
  }

  type Loan {
    id: ID!
    loanDate: DateTime!
    returnDate: DateTime
    dueDate: DateTime!
    deviceId: Device!
    loanerId: User!
    supplierId: User!
    returnerId: User
    createdAt: DateTime!
    updatedAt: DateTime!
  }

  type LoanConnection {
    pageInfo: PageInfo!
    edges: [LoanEdge]!
    aggregate: AggregateLoan!
  }

  input LoanCreateInput {
    id: ID
    loanDate: DateTime!
    returnDate: DateTime
    dueDate: DateTime!
    deviceId: DeviceCreateOneInput!
    loanerId: UserCreateOneWithoutLoansInput!
    supplierId: UserCreateOneInput!
    returnerId: UserCreateOneInput
  }

  input LoanCreateManyWithoutLoanerIdInput {
    create: [LoanCreateWithoutLoanerIdInput!]
    connect: [LoanWhereUniqueInput!]
  }

  input LoanCreateWithoutLoanerIdInput {
    id: ID
    loanDate: DateTime!
    returnDate: DateTime
    dueDate: DateTime!
    deviceId: DeviceCreateOneInput!
    supplierId: UserCreateOneInput!
    returnerId: UserCreateOneInput
  }

  type LoanEdge {
    node: Loan!
    cursor: String!
  }

  enum LoanOrderByInput {
    id_ASC
    id_DESC
    loanDate_ASC
    loanDate_DESC
    returnDate_ASC
    returnDate_DESC
    dueDate_ASC
    dueDate_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
  }

  type LoanPreviousValues {
    id: ID!
    loanDate: DateTime!
    returnDate: DateTime
    dueDate: DateTime!
    createdAt: DateTime!
    updatedAt: DateTime!
  }

  input LoanScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    loanDate: DateTime
    loanDate_not: DateTime
    loanDate_in: [DateTime!]
    loanDate_not_in: [DateTime!]
    loanDate_lt: DateTime
    loanDate_lte: DateTime
    loanDate_gt: DateTime
    loanDate_gte: DateTime
    returnDate: DateTime
    returnDate_not: DateTime
    returnDate_in: [DateTime!]
    returnDate_not_in: [DateTime!]
    returnDate_lt: DateTime
    returnDate_lte: DateTime
    returnDate_gt: DateTime
    returnDate_gte: DateTime
    dueDate: DateTime
    dueDate_not: DateTime
    dueDate_in: [DateTime!]
    dueDate_not_in: [DateTime!]
    dueDate_lt: DateTime
    dueDate_lte: DateTime
    dueDate_gt: DateTime
    dueDate_gte: DateTime
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    AND: [LoanScalarWhereInput!]
    OR: [LoanScalarWhereInput!]
    NOT: [LoanScalarWhereInput!]
  }

  type LoanSubscriptionPayload {
    mutation: MutationType!
    node: Loan
    updatedFields: [String!]
    previousValues: LoanPreviousValues
  }

  input LoanSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: LoanWhereInput
    AND: [LoanSubscriptionWhereInput!]
    OR: [LoanSubscriptionWhereInput!]
    NOT: [LoanSubscriptionWhereInput!]
  }

  input LoanUpdateInput {
    loanDate: DateTime
    returnDate: DateTime
    dueDate: DateTime
    deviceId: DeviceUpdateOneRequiredInput
    loanerId: UserUpdateOneRequiredWithoutLoansInput
    supplierId: UserUpdateOneRequiredInput
    returnerId: UserUpdateOneInput
  }

  input LoanUpdateManyDataInput {
    loanDate: DateTime
    returnDate: DateTime
    dueDate: DateTime
  }

  input LoanUpdateManyMutationInput {
    loanDate: DateTime
    returnDate: DateTime
    dueDate: DateTime
  }

  input LoanUpdateManyWithoutLoanerIdInput {
    create: [LoanCreateWithoutLoanerIdInput!]
    delete: [LoanWhereUniqueInput!]
    connect: [LoanWhereUniqueInput!]
    set: [LoanWhereUniqueInput!]
    disconnect: [LoanWhereUniqueInput!]
    update: [LoanUpdateWithWhereUniqueWithoutLoanerIdInput!]
    upsert: [LoanUpsertWithWhereUniqueWithoutLoanerIdInput!]
    deleteMany: [LoanScalarWhereInput!]
    updateMany: [LoanUpdateManyWithWhereNestedInput!]
  }

  input LoanUpdateManyWithWhereNestedInput {
    where: LoanScalarWhereInput!
    data: LoanUpdateManyDataInput!
  }

  input LoanUpdateWithoutLoanerIdDataInput {
    loanDate: DateTime
    returnDate: DateTime
    dueDate: DateTime
    deviceId: DeviceUpdateOneRequiredInput
    supplierId: UserUpdateOneRequiredInput
    returnerId: UserUpdateOneInput
  }

  input LoanUpdateWithWhereUniqueWithoutLoanerIdInput {
    where: LoanWhereUniqueInput!
    data: LoanUpdateWithoutLoanerIdDataInput!
  }

  input LoanUpsertWithWhereUniqueWithoutLoanerIdInput {
    where: LoanWhereUniqueInput!
    update: LoanUpdateWithoutLoanerIdDataInput!
    create: LoanCreateWithoutLoanerIdInput!
  }

  input LoanWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    loanDate: DateTime
    loanDate_not: DateTime
    loanDate_in: [DateTime!]
    loanDate_not_in: [DateTime!]
    loanDate_lt: DateTime
    loanDate_lte: DateTime
    loanDate_gt: DateTime
    loanDate_gte: DateTime
    returnDate: DateTime
    returnDate_not: DateTime
    returnDate_in: [DateTime!]
    returnDate_not_in: [DateTime!]
    returnDate_lt: DateTime
    returnDate_lte: DateTime
    returnDate_gt: DateTime
    returnDate_gte: DateTime
    dueDate: DateTime
    dueDate_not: DateTime
    dueDate_in: [DateTime!]
    dueDate_not_in: [DateTime!]
    dueDate_lt: DateTime
    dueDate_lte: DateTime
    dueDate_gt: DateTime
    dueDate_gte: DateTime
    deviceId: DeviceWhereInput
    loanerId: UserWhereInput
    supplierId: UserWhereInput
    returnerId: UserWhereInput
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    AND: [LoanWhereInput!]
    OR: [LoanWhereInput!]
    NOT: [LoanWhereInput!]
  }

  input LoanWhereUniqueInput {
    id: ID
  }

  scalar Long

  type Mutation {
    createDevCategory(data: DevCategoryCreateInput!): DevCategory!
    updateDevCategory(
      data: DevCategoryUpdateInput!
      where: DevCategoryWhereUniqueInput!
    ): DevCategory
    updateManyDevCategories(
      data: DevCategoryUpdateManyMutationInput!
      where: DevCategoryWhereInput
    ): BatchPayload!
    upsertDevCategory(
      where: DevCategoryWhereUniqueInput!
      create: DevCategoryCreateInput!
      update: DevCategoryUpdateInput!
    ): DevCategory!
    deleteDevCategory(where: DevCategoryWhereUniqueInput!): DevCategory
    deleteManyDevCategories(where: DevCategoryWhereInput): BatchPayload!
    createDevice(data: DeviceCreateInput!): Device!
    updateDevice(
      data: DeviceUpdateInput!
      where: DeviceWhereUniqueInput!
    ): Device
    updateManyDevices(
      data: DeviceUpdateManyMutationInput!
      where: DeviceWhereInput
    ): BatchPayload!
    upsertDevice(
      where: DeviceWhereUniqueInput!
      create: DeviceCreateInput!
      update: DeviceUpdateInput!
    ): Device!
    deleteDevice(where: DeviceWhereUniqueInput!): Device
    deleteManyDevices(where: DeviceWhereInput): BatchPayload!
    createLoan(data: LoanCreateInput!): Loan!
    updateLoan(data: LoanUpdateInput!, where: LoanWhereUniqueInput!): Loan
    updateManyLoans(
      data: LoanUpdateManyMutationInput!
      where: LoanWhereInput
    ): BatchPayload!
    upsertLoan(
      where: LoanWhereUniqueInput!
      create: LoanCreateInput!
      update: LoanUpdateInput!
    ): Loan!
    deleteLoan(where: LoanWhereUniqueInput!): Loan
    deleteManyLoans(where: LoanWhereInput): BatchPayload!
    createUser(data: UserCreateInput!): User!
    updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
    updateManyUsers(
      data: UserUpdateManyMutationInput!
      where: UserWhereInput
    ): BatchPayload!
    upsertUser(
      where: UserWhereUniqueInput!
      create: UserCreateInput!
      update: UserUpdateInput!
    ): User!
    deleteUser(where: UserWhereUniqueInput!): User
    deleteManyUsers(where: UserWhereInput): BatchPayload!
  }

  enum MutationType {
    CREATED
    UPDATED
    DELETED
  }

  interface Node {
    id: ID!
  }

  type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
  }

  type Query {
    devCategory(where: DevCategoryWhereUniqueInput!): DevCategory
    devCategories(
      where: DevCategoryWhereInput
      orderBy: DevCategoryOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [DevCategory]!
    devCategoriesConnection(
      where: DevCategoryWhereInput
      orderBy: DevCategoryOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): DevCategoryConnection!
    device(where: DeviceWhereUniqueInput!): Device
    devices(
      where: DeviceWhereInput
      orderBy: DeviceOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Device]!
    devicesConnection(
      where: DeviceWhereInput
      orderBy: DeviceOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): DeviceConnection!
    loan(where: LoanWhereUniqueInput!): Loan
    loans(
      where: LoanWhereInput
      orderBy: LoanOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Loan]!
    loansConnection(
      where: LoanWhereInput
      orderBy: LoanOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): LoanConnection!
    user(where: UserWhereUniqueInput!): User
    users(
      where: UserWhereInput
      orderBy: UserOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [User]!
    usersConnection(
      where: UserWhereInput
      orderBy: UserOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): UserConnection!
    node(id: ID!): Node
  }

  type Subscription {
    devCategory(
      where: DevCategorySubscriptionWhereInput
    ): DevCategorySubscriptionPayload
    device(where: DeviceSubscriptionWhereInput): DeviceSubscriptionPayload
    loan(where: LoanSubscriptionWhereInput): LoanSubscriptionPayload
    user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  }

  type User {
    id: ID!
    isActive: Boolean!
    userType: UserType!
    email: String!
    password: String!
    firstName: String
    lastName: String
    address: String
    personNumber: String
    phone: String
    loans(
      where: LoanWhereInput
      orderBy: LoanOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Loan!]
    createdAt: DateTime!
    updatedAt: DateTime!
  }

  type UserConnection {
    pageInfo: PageInfo!
    edges: [UserEdge]!
    aggregate: AggregateUser!
  }

  input UserCreateInput {
    id: ID
    isActive: Boolean
    userType: UserType!
    email: String!
    password: String!
    firstName: String
    lastName: String
    address: String
    personNumber: String
    phone: String
    loans: LoanCreateManyWithoutLoanerIdInput
  }

  input UserCreateOneInput {
    create: UserCreateInput
    connect: UserWhereUniqueInput
  }

  input UserCreateOneWithoutLoansInput {
    create: UserCreateWithoutLoansInput
    connect: UserWhereUniqueInput
  }

  input UserCreateWithoutLoansInput {
    id: ID
    isActive: Boolean
    userType: UserType!
    email: String!
    password: String!
    firstName: String
    lastName: String
    address: String
    personNumber: String
    phone: String
  }

  type UserEdge {
    node: User!
    cursor: String!
  }

  enum UserOrderByInput {
    id_ASC
    id_DESC
    isActive_ASC
    isActive_DESC
    userType_ASC
    userType_DESC
    email_ASC
    email_DESC
    password_ASC
    password_DESC
    firstName_ASC
    firstName_DESC
    lastName_ASC
    lastName_DESC
    address_ASC
    address_DESC
    personNumber_ASC
    personNumber_DESC
    phone_ASC
    phone_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
  }

  type UserPreviousValues {
    id: ID!
    isActive: Boolean!
    userType: UserType!
    email: String!
    password: String!
    firstName: String
    lastName: String
    address: String
    personNumber: String
    phone: String
    createdAt: DateTime!
    updatedAt: DateTime!
  }

  type UserSubscriptionPayload {
    mutation: MutationType!
    node: User
    updatedFields: [String!]
    previousValues: UserPreviousValues
  }

  input UserSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: UserWhereInput
    AND: [UserSubscriptionWhereInput!]
    OR: [UserSubscriptionWhereInput!]
    NOT: [UserSubscriptionWhereInput!]
  }

  enum UserType {
    ADMIN
    STAFF
    STUDENT
  }

  input UserUpdateDataInput {
    isActive: Boolean
    userType: UserType
    email: String
    password: String
    firstName: String
    lastName: String
    address: String
    personNumber: String
    phone: String
    loans: LoanUpdateManyWithoutLoanerIdInput
  }

  input UserUpdateInput {
    isActive: Boolean
    userType: UserType
    email: String
    password: String
    firstName: String
    lastName: String
    address: String
    personNumber: String
    phone: String
    loans: LoanUpdateManyWithoutLoanerIdInput
  }

  input UserUpdateManyMutationInput {
    isActive: Boolean
    userType: UserType
    email: String
    password: String
    firstName: String
    lastName: String
    address: String
    personNumber: String
    phone: String
  }

  input UserUpdateOneInput {
    create: UserCreateInput
    update: UserUpdateDataInput
    upsert: UserUpsertNestedInput
    delete: Boolean
    disconnect: Boolean
    connect: UserWhereUniqueInput
  }

  input UserUpdateOneRequiredInput {
    create: UserCreateInput
    update: UserUpdateDataInput
    upsert: UserUpsertNestedInput
    connect: UserWhereUniqueInput
  }

  input UserUpdateOneRequiredWithoutLoansInput {
    create: UserCreateWithoutLoansInput
    update: UserUpdateWithoutLoansDataInput
    upsert: UserUpsertWithoutLoansInput
    connect: UserWhereUniqueInput
  }

  input UserUpdateWithoutLoansDataInput {
    isActive: Boolean
    userType: UserType
    email: String
    password: String
    firstName: String
    lastName: String
    address: String
    personNumber: String
    phone: String
  }

  input UserUpsertNestedInput {
    update: UserUpdateDataInput!
    create: UserCreateInput!
  }

  input UserUpsertWithoutLoansInput {
    update: UserUpdateWithoutLoansDataInput!
    create: UserCreateWithoutLoansInput!
  }

  input UserWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    isActive: Boolean
    isActive_not: Boolean
    userType: UserType
    userType_not: UserType
    userType_in: [UserType!]
    userType_not_in: [UserType!]
    email: String
    email_not: String
    email_in: [String!]
    email_not_in: [String!]
    email_lt: String
    email_lte: String
    email_gt: String
    email_gte: String
    email_contains: String
    email_not_contains: String
    email_starts_with: String
    email_not_starts_with: String
    email_ends_with: String
    email_not_ends_with: String
    password: String
    password_not: String
    password_in: [String!]
    password_not_in: [String!]
    password_lt: String
    password_lte: String
    password_gt: String
    password_gte: String
    password_contains: String
    password_not_contains: String
    password_starts_with: String
    password_not_starts_with: String
    password_ends_with: String
    password_not_ends_with: String
    firstName: String
    firstName_not: String
    firstName_in: [String!]
    firstName_not_in: [String!]
    firstName_lt: String
    firstName_lte: String
    firstName_gt: String
    firstName_gte: String
    firstName_contains: String
    firstName_not_contains: String
    firstName_starts_with: String
    firstName_not_starts_with: String
    firstName_ends_with: String
    firstName_not_ends_with: String
    lastName: String
    lastName_not: String
    lastName_in: [String!]
    lastName_not_in: [String!]
    lastName_lt: String
    lastName_lte: String
    lastName_gt: String
    lastName_gte: String
    lastName_contains: String
    lastName_not_contains: String
    lastName_starts_with: String
    lastName_not_starts_with: String
    lastName_ends_with: String
    lastName_not_ends_with: String
    address: String
    address_not: String
    address_in: [String!]
    address_not_in: [String!]
    address_lt: String
    address_lte: String
    address_gt: String
    address_gte: String
    address_contains: String
    address_not_contains: String
    address_starts_with: String
    address_not_starts_with: String
    address_ends_with: String
    address_not_ends_with: String
    personNumber: String
    personNumber_not: String
    personNumber_in: [String!]
    personNumber_not_in: [String!]
    personNumber_lt: String
    personNumber_lte: String
    personNumber_gt: String
    personNumber_gte: String
    personNumber_contains: String
    personNumber_not_contains: String
    personNumber_starts_with: String
    personNumber_not_starts_with: String
    personNumber_ends_with: String
    personNumber_not_ends_with: String
    phone: String
    phone_not: String
    phone_in: [String!]
    phone_not_in: [String!]
    phone_lt: String
    phone_lte: String
    phone_gt: String
    phone_gte: String
    phone_contains: String
    phone_not_contains: String
    phone_starts_with: String
    phone_not_starts_with: String
    phone_ends_with: String
    phone_not_ends_with: String
    loans_every: LoanWhereInput
    loans_some: LoanWhereInput
    loans_none: LoanWhereInput
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    AND: [UserWhereInput!]
    OR: [UserWhereInput!]
    NOT: [UserWhereInput!]
  }

  input UserWhereUniqueInput {
    id: ID
    email: String
  }
`;
